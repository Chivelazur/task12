# Содержание

## 1. Описание задачи


## 2. Метод решения

### Идея



### Массив событий

Событие - это фиксация некоторого факта. Фактически большая часть событий указано в исходных данных:

1. station_entrance - вход спутника S в зону видимости станции T.
2. station_exit - выход спутника S из зоны видимости станции T.
3. russia_entrance - вход спутника S на территорию России.
4. russia_exit - выход спутника S с территории России.

Дополнительно к этим события добавить:

5. Заканчиваем скачку данных.

но не будем, потому что маловероятно и не имеет практической ценности.

У каждого события есть атрибуты:

- бла бла бла

События вида station_entrance и station_exit являются активными, в том смысле, что при наступлении этого события можно принимать решение, какой спутник будет наблюдать станция, если в зоне видимости несколько спутников.




Таким образом, исходный набор данных превращается в упорядоченный по времени массив событий (класс event_store).

Допущения: 

### Отслеживаемые данные

Чтобы корректно обрабатывать события, необходимо знать на момент наступления события:

1. satellite_visibility[T] - какие спутники находятся в зоне видимости станции Т.
2. satellite_processing[T] - какой спутник выгружает данные на станцию T (подмножество satellite_visibility).
3. satellite_russia - какие спутники сейчас пролетают над Россией, чтобы актуализировать занимаемый объем бортовой памяти на момент наступления события.
4. 


### Обработка событий

Практичность решения - не "вертим" станциям.
Можно расширить - добавить начальные данные о заполненной памяти.
Можно добавить ограничение по скорости наведения в алгоритм несложно.
В решении есть короткие сеансы - можно запретить станции переключаться, если сеанс меньше N секунд (для этого достаточно лего модифицировать стратегию), что даст более физичные решения.

Сам алогритм очень быстрый - занимает время скачка и выгрузка.

Плюсы алгоритмы - можно легко его менять и улучшать, он понятный.


Для обработки событий используется класс propagator.

_Событие типа 1_ - вход спутника S в зону видимости станции T:

1. Добавляем спутник в satellite_store.satellite_visibility для станции T.
2. Обновляем данные satellite_store о бортовой памяти согласно Алгоритму 1.
3. Записываем метрики в metrics.
4. Принимаем решение о начале скачивания данных спутника S на станцию T согласно Стратегии.
   1. Если начинаем скачивание, добавляем спутник в satellite_store.satellite_processing.
   2. Начинаем сессию для спутника и станции в sessions.

_Событие типа 2_ - выход спутника S из зоны видимости станции T.

1. Убираем спутник из satellite_store.satellite_visibility для станции T.
2. Обновляем данные satellite_store о бортовой памяти согласно Алгоритму 1.
3. Записываем метрики в metrics.
4. Если станция скачивала данные с этого спутника:
   1. Убираем спутник из satellite_store.satellite_processing.
   2. Переключаем станцию на другие спутники в зоне видимости согласно Стратегии.
   3. Завершаем сессию для спутника и станции в sessions.

_Событие типа 3_ - вход спутника S на территорию России.

1. Добавляем спутник в satellite_store.satellite_russia.
2. Обновляем данные satellite_store о бортовой памяти согласно Алгоритму 1.
3. Записываем метрики в metrics.

_Событие типа 4_ - выход спутника S с территории России.

1. Убираем спутник из satellite_store.satellite_russia.
2. Обновляем данные satellite_store о бортовой памяти согласно Алгоритму 1.
3. Записываем метрики в metrics.


_Алгоритм 1._ Обновление данных о бортовой памяти.

На вход подается моменты времени T0 предыдущего и T1 нового события.

На выходе обновляется состояние satellite_store и возвращаются метрики.

1. Спутники, которые находятся над Россией satellite_store.satellite_russia, но не передают данные: 
   1. Добавляем объем занятой бортовой памяти для каждого спутника согласно ТТХ с момента предыдущего события.
   2. Если объем занятой бортовой памяти превысил максимум, ставим максимум.
2. Спутники, которые ведут передачу данных на Землю satellite_store.satellite_processing:
   1. Убавляем объем занятой бортовой памяти для каждого спутника согласно ТТХ с момента предыдущего события.
   2. Если объем занятой бортовой памяти спутника S достиг 0, ставим.
      1. Тут допущение - можно было откатить и переключить станцию. Запускаем событие пересчета, и смотрим, можно ли было переключить станцию, ставим 0.

3. Возвращаем метрики:
   1. satellite_memory_used_percentage_average = средний процент заполнения бортовой памяти по всем спутникам.
   2. used_total = суммарный объем занятой бортовой памяти по всем спутникам.
   3. passed_data = суммарный объем данных, переданных со всех спутников на все станции.
   4. satellite_overloade_count = количество спутников, у которых полностью заполнена память.


### Стратегия

1. Скачиваем со спутника с максимально занятым объемом памяти.
2. Скачиваем со спутника, который быстрее всего передает данные.

## 3. Архитектура

Намеренно упрощенная.

### Общая схема

### Документация API

